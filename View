-- VIEW

CREATE VIEW  TEST_VIEW
AS
SELECT *FROM EMP; -- 기본적으로 일반 사용자는 VIEW를 생성할 권한이 없다.

CREATE VIEW TEST1_VIEW
AS
SELECT * FROM AAA;

DROP VIEW TEST_VIEW; -- VIEW를 살제해도 기반 테이블은 전혀 영향이 없다.

-- EMP 테이블에서 10번부서만 바라보는 VIEW
CREATE OR REPLACE VIEW EMP_DEPT10_VIEW
AS
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE DEPTNO=10;

SELECT * FROM EMP_DEPT10_VIEW;

SELECT * FROM EMP_DEPT10_VIEW
ORDER BY SAL DESC;

DROP VIEW EMP_DEPT10_VIEW;

CREATE OR REPLACE VIEW EMP_DEPT10_VIEW
AS
SELECT EMPNO, ENAME, DNAME, LOC, SAL, DEPTNO
FROM EMP NATURAL JOIN DEPT
WHERE DEPTNO=10;

SELECT * FROM EMP_DEPT10_VIEW
WHERE SAL >=2500;

DESC USER_VIEWS;
SELECT VIEW_NAME, TEXT
FROM USER_VIEWS; -- VIEW 확인

CREATE OR REPLACE NOFORCE VIEW EMP1982_VIEW(EMPLOYEE_ID, EMPLOYEE_NAME, HIRE_DATE, DEPARTMENT_NAME, LOCATION, DRPARTMENT_ID)
AS
SELECT EMPNO, ENAME, HIREDATE, DNAME, LOC, DEPTNO
FROM EMP INNER JOIN DEPT USING (DEPTNO) 
WHERE TO_CHAR(HIREDATE, 'YYYY') = '1981'
WITH READ ONLY;


SELECT * FROM EMP1982_VIEW;

INSERT INTO EMP1982_VIEW(EMPLOYEE_ID, EMPLOYEE_NAME)
VALUES(8888, '한지민'); -- VIEW도 DML이 가능하다.

ROLLBACK;

-- 단순뷰(SIMPLE VIEW)는 DML이 가능하고, 복합뷰는 DML이 불가능하다.

CREATE TABLE EMP
AS
SELECT * FROM DEPT;

CREATE OR REPLACE VIEW TEST_VIEW
AS
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 20
WITH CHECK OPTION; -- VIEW를 만들때 사용했던 WHERE절의 조건과 일치하는 경우에만 DML 사용허가

COMMIT; -- 여기로 롤백

INSERT INTO TEST_VIEW(EMPNO, ENAME, SAL, DEPTNO)
VALUES('9999', '김지민', 2000, 20);

ROLLBACK;

-- WITH CHECK OPTION은 조건절에 있는 조건을 만족할 때만, WHERE 조건을 만족하는 것만 처리
-- WITH READ ONLY는 전체 조건을 만족할 때만(전체를 대상으로 READ ONLY 수행)

CREATE OR REPLACE FORCE VIEW AAA_VIEW
AS
SELECT * FROM AAA;
-- FORCE는 기반테이블존재하지않아도 강제 생성

-- TOP-N QUERY, ROWNUM, INLINE VIEW
SELECT ROWNUM , ENAME, SAL
FROM EMP
WHERE ROWNUM <= 3
ORDER BY SAL DESC;

CREATE OR REPLACE VIEW EMP_SAL_DEC_VIEW
AS
SELECT ENAME, SAL
FROM EMP
ORDER BY SAL DESC;

SELECT ROWNUM, ENAME, SAL
FROM EMP_SAL_DEC_VIEW; -- 새로 만든 뷰에 새로 만든 ROWNUM
-- 이를 이용해서 TOP-N QUERY를 만들 수 있다.

-- 부서별로 부서명, 최소 급여, 최대 급여, 부서의 평균 급여를 포함하는 DEPT_SUM VIEW를 생성하라.
CREATE OR REPLACE VIEW DEPT_SUM(DEPTNO, DNAME, MIN_SAL, MAX_SAL, AVG_SAL)
AS
SELECT EMP.DEPTNO, DEPT.DNAME, MIN(SAL), MAX(SAL), TRUNC(AVG(SAL))
FROM EMP INNER JOIN DEPT ON (EMP.DEPTNO=DEPT.DEPTNO)
GROUP BY EMP.DEPTNO, DEPT.DNAME;

DESC DEPT_SUM;

SELECT *
FROM DEPT_SUM;

-- EMP TABLE에서 사원번호, 이름, 업무를 포함하는 EMP_VIEW VIEW를 생성하시오.
CREATE OR REPLACE VIEW EMP_VIEW
AS
SELECT EMPNO, ENAME, JOB, DEPTNO
FROM EMP;

SELECT *
FROM EMP_VIEW
WHERE DEPTNO=10;

-- 위에 생성한 VIEW를 DATE DICTIONARY에서 조회하시오.
SELECT VIEW_NAME, TEXT
FROM USER_VIEWS
WHERE VIEW_NAME = UPPER('EMP_VIEW');

-- 이름, 업무, 급여, 부서명, 위치를 포함하는 EMP_DEPT_NAME 이라는  VIEW를 생성하시오.
CREATE OR REPLACE VIEW EMP_DEPT_NAME
AS
SELECT ENAME, JOB, SAL, DNAME, LOC
FROM EMP E INNER JOIN DEPT D ON E.DEPTNO=D.DEPTNO;

SELECT *
FROM EMP_DEPT_NAME;

-- 87년에 입사한 사람을 볼 수 있는 뷰
CREATE OR REPLACE VIEW EMP1987_VIEW
AS
SELECT EMPNO, ENAME, HIREDATE
FROM EMP
-- WHERE HIREDATE LIKE '87%';
-- WHERE HIREDATE BETWEEN '87/01/01' AND '87/12/31';
-- WHERE SUBSTR(HIREDATE,1,2) = '87'; 
WHERE TO_CHAR(HIREDATE, 'YYYY') = '1987';

SELECT PARAMETER, VALUE
FROM NLS_SESSION_PARAMETERS;

-- DEPT TABLE의 기본키 열로 사욜할 시퀀스를 다음 조건에 맞게 생성하시오.
-- 1) 시퀀스 값은 60에서 시작하여 10씩 증가하며 최대 200까지 가능하도록 한다.
-- 2) 시퀀스 이름은 DEPT_DEPTNO_SEQ로 지정한다.
CREATE SEQUENCE DEPT_DEPTNO_SEQ
    START WITH 60
    INCREMENT BY 10
    MAXVALUE 200;

SELECT SEQUENCE_NAME, MAX_VALUE, INCREMENT_BY, LAST_NUMBER
FROM USER_SEQUENCES
WHERE SEQUENCE_NAME = 'DEPT_DEPTNO_SEQ';

COMMIT;
-- 위에만든 시퀀스를 이용하여 부서이름은 EDUCATION, 부서 위치는 SEOUL로 새 행을 DEPT테이블에 추가하고 조회하시오
INSERT INTO DEPT
VALUES(DEPT_DEPTNO_SEQ.NEXTVAL, 'EDUCATION', 'SEOUL');

SELECT * FROM DEPT;
ROLLBACK;
